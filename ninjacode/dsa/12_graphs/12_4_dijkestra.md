<div _ngcontent-serverapp-c318="" class="body-text p-24"><p><strong>Dijkstra Algorithm : Minimum Path Length</strong></p><p><span style="font-size:13.33px;">This algorithm is used to find the shortest distance between any two vertices in a weighted non-cyclic graph.</span></p><p><span style="font-size:13.33px;">Here, we will be using a slight modification of the algorithm according to which we will be figuring out the minimum distance of all the vertices from the particular source vertex.</span></p><p><span style="font-size:13.33px;">Let’s consider the algorithm with an example:</span></p><ol style="list-style-type:decimal;"><li><span style="font-size:13.33px;">We want to calculate the shortest path between the source vertex C and all other vertices in the following graph.</span></li></ol><p><img class="image_resized" style="width:385px;" src="https://files.codingninjas.in/note_1371_a77d8ff46b9e_1.png" alt=""></p><ol style="list-style-type:decimal;"><li><span style="font-size:13.33px;">While executing the algorithm, we will mark every node with its <strong>minimum distance </strong>to the selected node, which is C in our case. Obviously, for node C itself, this distance will be 0, and for the rest of the nodes, we will assume that the distance is infinity, which also denotes that these vertices have not been visited till now.</span><img class="image_resized" style="width:483px;" src="https://files.codingninjas.in/note_1371_0c93aad72ac7_2.png" alt=""></li><li><span style="font-size:13.33px;">Now, we will check for the neighbors of the current node, which are A, B, and D. Now, we will add the minimum cost of the current node to the weight of the edge connecting the current node and the particular neighbor node. For example, for node B, its weight will become minimum(infinity, 0+7) = 7. This same process is repeated for other neighbor nodes.</span></li></ol><p style="margin-left:48px;text-align:center;"><img class="image_resized" style="width:413px;" src="https://files.codingninjas.in/note_1371_a1656a55be13_3.png" alt=""></p><ol style="list-style-type:decimal;"><li><span style="font-size:13.33px;">Now, as we have updated the distance of all the neighbor nodes of the current node, we will mark the current node as visited.</span></li></ol><p style="margin-left:48px;text-align:center;"><img class="image_resized" style="width:462px;" src="https://files.codingninjas.in/note_1371_72e39b126e66_4.png" alt=""></p><ol style="list-style-type:decimal;"><li><span style="font-size:13.33px;">After this, we will be selecting the minimum weighted node among the remaining vertices. In this case, it is node A. Take this node as the current node.</span></li><li><span style="font-size:13.33px;">Now, we will repeat the above steps for the rest of the vertices. The pictorial representation of the same is shown below:</span></li></ol><p style="text-align:center;"><img class="image_resized" style="width:430px;" src="https://files.codingninjas.in/note_1371_cbbe470af60b_5.png" alt=""></p><p style="text-align:center;">&nbsp;</p><p style="text-align:center;"><img class="image_resized" style="width:458px;" src="https://files.codingninjas.in/note_1371_e97e5067b647_6.png" alt=""></p><p style="text-align:center;"><img class="image_resized" style="width:440px;" src="https://files.codingninjas.in/note_1371_71152188294f_7.png" alt=""></p><p style="text-align:center;">&nbsp;</p><p><img class="image_resized" style="width:294px;" src="https://files.codingninjas.in/note_1371_a79d333ba52e_8.png" alt=""></p><ol style="list-style-type:decimal;"><li><span style="font-size:13.33px;">Finally, we will get the graph as follows:</span></li></ol><p style="margin-left:48px;text-align:center;"><img class="image_resized" style="width:403px;" src="https://files.codingninjas.in/note_1371_cad5b6c347f3_9.png" alt=""></p><p><span style="font-size:13.33px;">The distances finally marked at each node are minimum from node C.</span></p><p style="margin-left:-1px;"><span style="color:#000000;font-size:13.33px;"><strong>Time Complexity of Dijkstra’s algorithm:</strong></span></p><p><span style="font-size:13.33px;">The time complexity is also the same as that of Prim’s algorithm, i.e.,<strong> O(n<sup>2</sup>)</strong>. This can be reduced by using the same approaches as discussed in Prim’s algorithm’s content.</span></p><p>&nbsp;</p></div>