<div _ngcontent-serverapp-c318="" class="body-text p-24"><p><span style="font-size:17pt;"><strong>Graph Traversals</strong></span></p><p>&nbsp;</p><p><span style="font-size:11pt;">The graph traversal means to travel across all the nodes of the graph.</span></p><p><span style="font-size:11pt;">Traversal is done because of the following reasons -&nbsp;</span></p><ol><li><span style="font-size:11pt;">To access the data of nodes in the graph.</span></li><li><span style="font-size:11pt;">To search for a particular value in the graph.</span></li><li><span style="font-size:11pt;">To apply algorithms like shortest distance, distance between nodes, etc.</span></li><li><span style="font-size:11pt;">To find the neighbouring nodes of a given node.</span></li></ol><p>&nbsp;</p><p><span style="font-size:11pt;">There are two techniques of graph traversal -&nbsp;</span></p><ol><li><span style="font-size:11pt;">Breadth First Search (BFS)</span></li><li><span style="font-size:11pt;">Depth First Search (DFS)</span></li></ol><p>&nbsp;</p><p>&nbsp;</p><p><span style="font-size:13.999999999999998pt;"><strong>Breadth First Search (BFS)</strong></span></p><p><span style="font-size:11pt;">As the name suggests, BFS means to traverse across the breadth of the graph.</span></p><p><span style="font-size:11pt;">There will be a starting node from which we will start the BFS. The main properties of BFS are -&nbsp;</span></p><ol><li><span style="font-size:11pt;">BFS works from one level to the next level of graph.</span></li><li><span style="font-size:11pt;">If we start from any node, that node will be accessed.&nbsp;</span></li><li><span style="font-size:11pt;">After that all the neighbouring nodes will be accessed.</span></li><li><span style="font-size:11pt;">Then the next neighbouring nodes will be accessed and so on.</span></li><li><span style="font-size:11pt;">A&nbsp;<strong>queue</strong> data structure is used which is based on FIFO principle.</span></li><li><span style="font-size:11pt;">There is a visited boolean vector which signifies whether the node is visited or not.</span></li></ol><p>&nbsp;</p><p><span style="font-size:13.999999999999998pt;"><strong>BFS Algorithm&nbsp;</strong></span></p><ol><li><span style="font-size:11pt;">Start from any node. Push the node in the queue.</span></li><li><span style="font-size:11pt;">Now, the size of the queue will determine one level of the graph.&nbsp;</span></li><li><span style="font-size:11pt;">We pop the front node till the size of the queue.&nbsp;</span></li><li><span style="font-size:11pt;">The neighbouring nodes are tracked from the adjacency list of the from node and if the neighbouring node is not visited, it is pushed to the queue and visited value becomes false for that node.</span></li><li><span style="font-size:11pt;">Whenever the front node is popped from the queue, it is pushed back to the answer vector.</span></li><li><span style="font-size:11pt;">The algorithm continues till the queue becomes empty.</span></li></ol><p>&nbsp;</p><p><span style="font-size:11pt;"><strong>Time complexity - O(N)&nbsp;</strong></span></p><p><span style="font-size:11pt;">N = number of nodes.</span></p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/graph-traversals-dsa-new-0-1702720199.webp"></span></p><p>&nbsp;</p><p>&nbsp;</p><p><span style="font-size:13.999999999999998pt;"><strong>Depth First Search (DFS)</strong></span></p><p><span style="font-size:11pt;">In this algorithm, we travel across the depth of the graph first. The algorithm starts from any node and then moves to its adjacent node till the node is visited already.</span></p><p><span style="font-size:11pt;">The major properties of DFS are -&nbsp;</span></p><ol><li><span style="font-size:11pt;">Recursion is used to implement DFS.</span></li><li><span style="font-size:11pt;">Sometimes stack data structure is also used which is based on LIFO principle.</span></li><li><span style="font-size:11pt;">One depth is completed and then we return to access the other depth of the graph.</span></li><li><span style="font-size:11pt;">There is a visited boolean vector which signifies whether the node is visited or not.</span></li></ol><p>&nbsp;</p><p><span style="font-size:13.999999999999998pt;"><strong>DFS Algorithm&nbsp;</strong></span></p><ol><li><span style="font-size:11pt;">Start from any node and mark the visited vector value of that node as true.</span></li><li><span style="font-size:11pt;">We go to the adjacency list of the current node and check each of its neighbouring nodes.</span></li><li><span style="font-size:11pt;">If the neighbouring node is already visited, move to the next node.</span></li><li><span style="font-size:11pt;">Otherwise we make a recursive call on that node.</span></li><li><span style="font-size:11pt;">Whenever a recursive call is made on a node, the visitor vector value is marked as true and it is pushed back in the answer vector.</span></li></ol><p>&nbsp;</p><p><span style="font-size:11pt;"><strong>Time Complexity - O(N)</strong></span></p><p><span style="font-size:11pt;">N = number of nodes.</span></p><p>&nbsp;</p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/graph-traversals-dsa-new-1-1702720200.webp"></span></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p></div>