<div _ngcontent-serverapp-c318="" class="body-text p-24"><p><span style="font-size:34.67px;"><strong>Introduction to Recursion</strong></span><img class="image_resized" style="width:624px;" src="https://files.codingninjas.in/note_559_6a932890d2ca_1.png" alt="footer line"></p><p style="text-align:justify;">&nbsp;</p><p><span style="font-size:14.67px;">Any function which calls itself is called recursion. <strong>A recursive method solves a problem by calling a copy of itself to work on a smaller problem. </strong>Each time a function calls itself with a slightly simpler version of the original problem. This sequence of smaller problems must eventually converge on a base case.</span></p><p><span style="font-size:14.67px;">&nbsp;</span></p><p><span style="font-size:17.33px;">Working of recursion</span></p><p>&nbsp;</p><p><span style="font-size:14.67px;">We can define the steps of the recursive approach by summarizing the above three steps:</span></p><ul style="list-style-type:disc;"><li><span style="font-size:14.67px;"><strong>Base case: A recursive function must have a terminating condition at which the process will stop calling itself. Such a case is known as the base case. In the absence of a base case, it will keep calling itself and get stuck in an infinite loop. Soon, the recursion depth* will be exceeded and it will throw an error.</strong></span></li><li><span style="font-size:14.67px;"><strong>Recursive call (Smaller problem): The recursive function will invoke itself on a smaller version of the main problem. We need to be careful while writing this step as it is crucial to correctly figure out what your smaller problem is.</strong></span></li><li><span style="font-size:14.67px;"><strong>Self-work : Generally, we perform a calculation step in each recursive call. We can achieve this calculation step before or after the recursive call depending upon the nature of the problem.</strong></span></li></ul><p><span style="font-size:14.67px;"><strong>Note*: </strong>Recursion uses an in-built stack that stores recursive calls. Hence, the number of recursive calls must be as small as possible to avoid memory-overflow. If the number of recursion calls exceeded the maximum permissible amount, the <strong>recursion depth*</strong> will be exceeded. This condition is called <strong>stack overflow</strong>.</span></p><p><span style="font-size:14.67px;">Now, let us see how to solve a few common problems using Recursion.</span></p><p><span style="font-size:14.67px;">&nbsp;</span></p><p><span style="font-size:14.67px;"><strong>Problem Statement - Find Factorial of a number n.</strong></span></p><p><span style="font-size:14.67px;">&nbsp;</span></p><p><span style="font-size:14.67px;"><strong>Factorial of any number n is defined as n! = n * (n-1) * (n-2) * … *1. Ex: 5! = 5 * 4 * 3 * 2 * 1 = 120;&nbsp;</strong></span></p><p><span style="font-size:14.67px;">Let n = 5 ;</span></p><p><img class="image_resized" style="width:602px;" src="https://files.codingninjas.in/note_559_aaccf1cd79b5_2.png" alt=""></p><p><span style="font-size:14.67px;">In recursion, the idea is that we represent a problem in terms of smaller problems. We know that 5! = 5 * 4!. Let’s assume that recursion will give us an answer of 4!. Now to get the solution to our problem will become 5 * (the answer of the recursive call).</span></p><p><span style="font-size:14.67px;">&nbsp;</span></p><p><span style="font-size:14.67px;">Similarly, when we give a recursive call for 4!; recursion will give us an answer of 3!. Since the same work is done in all these steps we write only one function and give it a call recursively. Now, what if there is no base case? Let's say 1! Will give a call to 0!; 0! will give a call to -1! (doesn’t exist) and so on. Soon the function call stack will be full of method calls and give an error<strong> Stack Overflow. </strong>To avoid this we need a base case. So in the base case, we put our own solution to one of the smaller problems.</span></p><p>&nbsp;</p><p><span style="font-size:14.67px;">function factorial(n) &nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &nbsp; base case</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if n equals 0</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return 1</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; getting answer of the smaller problem&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recursionResult = factorial(n-1) &nbsp; &nbsp;&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;self work&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = n * recursionResult &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ans</span></p><p><span style="font-size:14.67px;"><strong>&nbsp;</strong></span></p><p><span style="font-size:14.67px;"><strong>Problem Statement - Find nth fibonacci.</strong></span></p><p><span style="font-size:14.67px;">&nbsp;</span></p><p><span style="font-size:14.67px;">We know that Fibonacci numbers are defined as follows&nbsp;</span></p><p><span style="font-size:14.67px;"><strong>fibo(n)</strong> = n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for n &lt;= 1</span></p><p><span style="font-size:14.67px;"><strong>fibo(n)</strong> = fibo (n - 1) + fibo (n - 2) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; otherwise</span></p><p><span style="font-size:14.67px;">Let n = 4</span></p><p><img class="image_resized" style="width:602px;" src="https://files.codingninjas.in/note_559_e0100b766f32_3.png" alt=""></p><p><span style="font-size:14.67px;">As you can see from the above fig and recursive equation that the bigger problem is dependent on 2 smaller problems.</span></p><p><span style="font-size:14.67px;">Depending upon the question, the bigger problem can depend on N number of smaller problems.</span></p><p><span style="font-size:14.67px;">&nbsp;</span></p><p><span style="font-size:14.67px;">function fibonacci(n) &nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &nbsp; base case</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if n equals 1 OR 0</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return n</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; getting answer of the smaller problem&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recursionResult1 = fibonacci(n - 1) &nbsp; &nbsp;&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recursionResult2 = fibonacci(n - 2) &nbsp; &nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp;self work&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = recursionResult1 + recursionResult2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ans</span></p><p><span style="font-size:14.67px;"><strong>&nbsp;</strong></span></p><p><span style="font-size:14.67px;"><strong>Problem Statement - Check if an array is sorted</strong></span></p><p><span style="font-size:14.67px;">&nbsp;</span></p><p><span style="font-size:14.67px;"><strong>For example:&nbsp;</strong></span></p><ul style="list-style-type:disc;"><li><span style="font-size:14.67px;">If the array is {2, 4, 8, 9, 9, 15}, then the output should be <strong>true.</strong></span></li><li><span style="font-size:14.67px;">If the array is {5, 8, 2, 9, 3}, then the output should be <strong>false.</strong></span></li></ul><p><img class="image_resized" style="width:602px;" src="https://files.codingninjas.in/note_559_56a103ec4167_4.png" alt=""></p><p><span style="font-size:14.67px;">function isArraySorted(arr, idx) &nbsp; &nbsp;// &nbsp; 0 is passed in idx</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// &nbsp; base case</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if idx equals arr.length - 1</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return true</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; getting answer of the smaller problem&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; recursionResult = isArraySorted(arr, idx+1) &nbsp; &nbsp;&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // &nbsp; self work&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ans = recursionResult &amp; arr[idx] &lt;= arr[idx+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p><p><span style="font-size:14.67px;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return ans</span></p><p style="margin-left:0px;text-align:justify;">&nbsp;</p></div>