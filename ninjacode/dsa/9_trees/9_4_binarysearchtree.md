<div _ngcontent-serverapp-c318="" class="body-text p-24"><p><span style="font-size:17pt;"><strong>Binary Search Tree</strong></span></p><p>&nbsp;</p><p><span style="font-size:11pt;">Binary search trees are the most amazing concept when we study tree data structures.</span></p><p><span style="font-size:11pt;">It is so because the access time complexity of data is much more efficient than the normal binary tree.</span></p><p>&nbsp;</p><p><span style="font-size:11pt;">Binary search tree has the following properties -&nbsp;</span></p><ol><li><span style="font-size:11pt;">It follows all the properties of a binary tree. That is any node can have utmost 2 child nodes.</span></li><li><span style="font-size:11pt;">The data value of the left child node will be&nbsp;<strong>less</strong> than the data value of the parent node.</span></li><li><span style="font-size:11pt;">The data value of the right child node will be&nbsp;<strong>greater</strong> than the data value of the parent node.</span></li><li><span style="font-size:11pt;">All the subtrees are also Binary Search Trees.</span></li></ol><p>&nbsp;</p><p><span style="font-size:13.999999999999998pt;"><strong>Construction of Binary Search Tree</strong></span></p><p><span style="font-size:11pt;">Let us take an example and construct a binary search tree by putting all the nodes one by one.</span></p><p><span style="font-size:11pt;">Example - We want to construct a BST where the values of the nodes are given in order.</span></p><p><span style="font-size:11pt;">[12, 15, 17, 1, 19, 13, 11, 16]</span></p><p>&nbsp;</p><p><span style="font-size:11pt;"><strong>Solution -&nbsp;</strong>since the node values are given in order, we have to add them one by one.&nbsp;</span></p><p><span style="font-size:11pt;">The root will be 12.&nbsp;</span></p><p>&nbsp;</p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-0-1702466088.jpg"></span></p><p>&nbsp;</p><p><span style="font-size:11pt;">Now we need to add 15. Since 15&gt;12, thus it will be the right child of 12.</span></p><p>&nbsp;</p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-1-1702466089.webp"></span></p><p><span style="font-size:11pt;">The next value is 17. We compare it to 12 and 17&gt;12. So we move to the right part and compare it to 15. From 17&gt;15, it will be placed in the right child.</span></p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-2-1702466090.webp"></span></p><p>&nbsp;</p><p><span style="font-size:11pt;">We add 1 now. Compare it to 12. From, 1&lt;12. We place it at the left child.</span></p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-3-1702466090.webp"></span></p><p>&nbsp;</p><p><span style="font-size:11pt;">We add 19 now. Compare it to 12. From 19&gt;12, 19&gt;15 and 19&gt;17. We place it at the right child of 17.</span></p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-4-1702466091.webp"></span></p><p>&nbsp;</p><p>&nbsp;</p><p><span style="font-size:11pt;">Again 13&gt;12, so we move to the right part. Now 13&lt;15. So we keep it at the left child of 15.</span></p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-5-1702466091.webp"></span></p><p>&nbsp;</p><p><span style="font-size:11pt;">Now, we add 11. Since 11&lt;12, we move to the left part. Here 11&gt;1, so we keep it at the right child of 1.</span></p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-6-1702466092.webp"></span></p><p>&nbsp;</p><p><span style="font-size:11pt;">The last node is 16. We compare it to 12 and move to the right part. Similar for 15. We compare it to 17. Since 16&lt;17, we put it at the left child of 17.</span></p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-7-1702466092.webp"></span></p><p><span style="font-size:11pt;">This is the final binary search tree. As you can see, all the subtrees are BST. The left child has less value and the right child has greater value than the parent node respectively.</span></p><p>&nbsp;</p><p><span style="font-size:13.999999999999998pt;"><strong>Important properties of BST</strong></span></p><ol><li><span style="font-size:11pt;">The&nbsp;<strong>in order traversa</strong>l of BST is always sorted in ascending order.</span></li><li><span style="font-size:11pt;">The&nbsp;<strong>largest</strong> value of BST will always be the right and bottom most leaf node.</span></li><li><span style="font-size:11pt;">The&nbsp;<strong>smallest</strong> value of BST will always be the left and bottom most leaf node.</span></li><li><span style="font-size:11pt;">All the nodes in a BST will have unique data values.</span></li></ol><p>&nbsp;</p><p>&nbsp;</p><p><span style="font-size:13.999999999999998pt;"><strong>Searching in a BST</strong></span></p><p><span style="font-size:11pt;">Searching in a BST is very efficient as it uses the principle of binary search.</span></p><p><span style="font-size:11pt;">If we want to search for any node of a given data value, then the following principle is applied.</span></p><p>&nbsp;</p><p><span style="font-size:13.999999999999998pt;"><strong>General Principle</strong></span></p><ul><li><span style="font-size:11pt;">Binary search can be easily applied in BST. Thus, its name is binary search tree.</span></li><li><span style="font-size:11pt;">Whenever we want to search any data value in the BST, we check first for the root value. There are 3 possibilities.</span></li></ul><ol><li><p style="margin-left:36pt;"><span style="font-size:11pt;">If the root value is equal to the given data value, We return the root.</span></p></li><li><p style="margin-left:36pt;"><span style="font-size:11pt;">If the root value is&nbsp;<strong>greater</strong> than the given data value, we move to the&nbsp;<strong>left subtree&nbsp;</strong>as the values in the right subtree will also be greater than the given data value.</span></p></li><li><p style="margin-left:36pt;"><span style="font-size:11pt;">If the root value is&nbsp;<strong>less</strong> than the given data value, we move to the&nbsp;<strong>right subtree&nbsp;</strong>as the values in the left subtree will also be less than the given data value.</span></p></li></ol><ul><li><span style="font-size:11pt;">Thus, at every stage we are either moving to the right or the left subtree.&nbsp;</span></li><li><span style="font-size:11pt;">This makes us move to the next level in the tree at every stage. Thus, at every level, we need to compare only one node of the tree.</span></li><li><span style="font-size:11pt;">Thus, the time complexity of searching becomes&nbsp;<strong>O(height of the tree).</strong></span></li><li><span style="font-size:11pt;">In the&nbsp;<strong>average</strong>&nbsp;<strong>case</strong>, the height of the tree of BST is&nbsp;<strong>logn.&nbsp;</strong>Thus, in the average case, the time complexity becomes&nbsp;<strong>O(logn).</strong></span></li><li><span style="font-size:11pt;">Whereas in the worst case the time complexity remains&nbsp;<strong>O(n)&nbsp;</strong>only.&nbsp;</span></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p><span style="font-size:11pt;">The C++ code for searching in BST is as shown.</span></p><p>&nbsp;</p><p><span style="font-size:11pt;"><img src="https://files.codingninjas.in/article_images/binary-search-tree-dsa-new-8-1702466093.webp"></span></p><p>&nbsp;</p><p>&nbsp;</p></div>